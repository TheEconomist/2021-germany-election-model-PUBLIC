library(tidyverse)
library(zoo)
library(lubridate)
library(gridExtra)
library(pbapply)
library(mgcv)

# metadata
MASTER_days_until_2021_election = as.numeric(ymd('2021-09-26') - pmin(Sys.Date(),ymd('2021-09-26')))

# import polls ------------------------------------------------------------
# scrape new polls and read them in
# system("pipenv install") # if you haven't installed the python workspace yet
system("pipenv run scripts/fetch_2021_polls.py")

polls_2020 <- read_csv("output-data/all-polls-2021.csv") %>%
  dplyr::select(-1) %>%
  mutate(
    start = as_date(start), end = as_date(end),
    start = as_date(ifelse(start > end, start - 365, start)),
    mid = as_date(start + round(as.numeric(end - start) / 2))
  ) %>%
  # standardize party names for historical data
  mutate(party = case_when(party == "CDU/CSU" ~ "cdu",
                           party == "SPD" ~ "spd",
                           party == "GRÃœNE" ~ 'gru',
                           party == "FDP" ~ 'fdp',
                           party == "LINKE" ~ 'lin',
                           party == "AfD" ~ 'afd',
                           party == "Sonstige" ~ 'oth')) %>%
  dplyr::filter(!date > Sys.Date())

# optimized loess trend ---------------------------------------------------
polls_2020 <- polls_2020 %>%
  group_by(poll) %>%
  mutate(n = ifelse(is.na(n), mean(n, na.rm = T), n)) %>%
  ungroup() %>%
  mutate(n = ifelse(is.na(n), mean(n, na.rm = T), n)) %>%
  ungroup()

mean(polls_2020$n)

# first, draw trends in same manner as historically
polls_2020_demo <- polls_2020
gam_knots <- lapply(
  seq(4,pmin(150, nrow(na.omit(polls_2020_demo))),2),
  function(x) {
    # print(x)
    rmse_in <- try((polls_2020_demo %>%
                      dplyr::filter(party == "cdu") %>%
                      mutate(mid = as.numeric(mid)) %>%
                      arrange(mid) %>%
                      mutate(loess_trend = predict(gam(share ~ s(mid,k=x),
                                                       weights = sqrt(n / 1917),
                      ),newdata = .)) %>%
                      mutate(loess_trend = case_when(loess_trend > 1 ~ 1, 
                                                     loess_trend < 0 ~ 0,
                                                     TRUE ~ loess_trend),
                             error = loess_trend - lead(share)) %>%
                      pull(error) %>% na.omit() %>% .^2 %>% mean() %>% sqrt() ))
    
    if (!is.numeric(rmse_in)) {
      return(NULL)
    } else {
      # print(rmse_in)
      return(tibble(knots = x, rmse = rmse_in))
    }
  }
) %>%
  bind_rows() %>%
  na.omit()

gam_knots
optimal_knots <- gam_knots$knots[which(gam_knots$rmse == min(gam_knots$rmse))][1]
optimal_knots

# expand DF to include one row for each day * demog var combination
polls_2020_demo <-
  expand_grid(
    mid = seq.Date(
      min(polls_2020_demo$mid),
      max(polls_2020_demo$mid), 1
    ),
    party = unique(polls_2020_demo$party)
  ) %>%
  left_join(polls_2020_demo)

# nested smoothing for each category
polls_2020_with_trends <- lapply(
  unique(polls_2020_demo$party),
  function(z) {
    polls_2020_demo %>%
      dplyr::filter(party == z) %>%
      mutate(mid = as.numeric(mid)) %>%
      group_by(party) %>%
      arrange(mid) %>%
      mutate(
        loess_trend = predict(gam(share ~ s(mid,k=optimal_knots),
                                  weights = sqrt(n / 1917)),
                              newdata = .),
        loess_trend = case_when(loess_trend > 1 ~ 1, 
                                loess_trend < 0 ~ 0,
                                TRUE ~ loess_trend),
        loess_moe = sqrt(mean((loess_trend - share)^2, na.rm = T)) * 2
      ) %>%
      mutate(mid = as_date(mid))
  }
) %>%
  bind_rows()


# for remainder of time, inflate error by constant and regress towards mean -----------
# function
predict_from_nested_gam <- function(y, x, knots, weight) {
  model <- gam(y ~ s(x, k = knots))
  return(predict(model, tibble(x = x)))
}

# these values are hard-coded, generated by the calculate_optimal_decays script
optimized_mean_weight_decay = -0.003216095
optimized_trend_weight_decay = -0.150951232

get_predicted_sd <- function(days_since_last_survey, est_share){
  pmax(0,
       0.00316150 + 
         (sqrt(days_since_last_survey) * -0.00048204) + 
         (est_share * -0.03417641) +
         (sqrt(days_since_last_survey) *est_share * 0.01442846) 
       
  )
  
}

plot(get_predicted_sd(1:100, 0.05))

# nested smoothing for each category
# first, expand ts to today
polls_2020_with_trends_forecast <-
  expand_grid(
    mid = seq.Date(
      min(polls_2020_with_trends$mid),
      max(polls_2020_with_trends$mid) + MASTER_days_until_2021_election,
      1
    ),
    party = unique(polls_2020_with_trends$party)
  ) %>%
  left_join(polls_2020_with_trends, by = c("mid", "party")) %>%
  mutate(
    days_since_last_survey = as.numeric(mid - max(polls_2020_with_trends$mid)),
    to_impute = ifelse(days_since_last_survey > 0, TRUE, FALSE),
    mid = as_date(mid)
  )


# then calculate guess at how trend line would continue
polls_2020_with_trends_forecast <- polls_2020_with_trends_forecast %>%
  ungroup() %>%
  # dplyr::filter(party == z) %>%
  mutate(mid = as.numeric(as_date(mid))) %>%
  group_by(party) %>%
  arrange(party, mid) %>%
  # as time goes on without polls, put less weight on trend and more on average
  mutate(
    # continued_loess_trend = na_kalman(loess_trend,smooth=T,model='auto.arima'),
    continued_loess_trend = predict_from_nested_gam(y = loess_trend, x = mid, knots = 300),
    rolling_mean_trend = rollapply(data=loess_trend,width=30*3,align='right',FUN=mean,partial=T),
    continued_loess_trend = case_when(
      continued_loess_trend < 0 ~ 0,
      continued_loess_trend > 1 ~ 1,
      TRUE ~ continued_loess_trend
    ),
    rolling_mean_trend = case_when(
      rolling_mean_trend < 0 ~ 0,
      rolling_mean_trend > 1 ~ 1,
      TRUE ~ rolling_mean_trend
    ),
    last_loess_trend = last(loess_trend[!is.na(loess_trend)]),
    last_rolling_mean_trend = last(rolling_mean_trend[!is.na(rolling_mean_trend)]),
    last_loess_moe = last(loess_moe[!is.na(loess_moe)]),
    weight_on_mean = pmax(0, 1 - exp(days_since_last_survey * optimized_mean_weight_decay)),
    weight_on_trend = exp(days_since_last_survey * optimized_trend_weight_decay),
    weight_on_latest_poll = 1 - (weight_on_mean + weight_on_trend),
    weight_on_mean = to_impute * weight_on_mean,
    weight_on_trend = to_impute * weight_on_trend,
    weight_on_latest_poll = to_impute * weight_on_latest_poll,
    extrapolated_loess_trend = ifelse(to_impute,
                                      (last_rolling_mean_trend * weight_on_mean) +
                                        (last_loess_trend * weight_on_latest_poll) +
                                        (continued_loess_trend * weight_on_trend),
                                      loess_trend
    ),
    extrapolated_loess_moe = ifelse(to_impute,
                                    last_loess_moe + get_predicted_sd(days_since_last_survey, extrapolated_loess_trend) * 3,
                                    loess_moe
    ),
    mid = as_date(mid)
  )


# plot
gg1 <- polls_2020_with_trends_forecast %>%
  filter(party != "oth") %>%
  # filter(mid >= ymd("2020-01-01")) %>%
  ggplot(., aes(x = mid, col = party)) +
  geom_point(aes(y = share), alpha = 0.1) +
  geom_line(aes(y = loess_trend)) +
  geom_line(aes(y = rolling_mean_trend), linetype = 2) +
  labs(x = "", y = "", col = "Party") +
  scale_y_continuous(labels = function(x) {
    x * 100
  }, limits = c(0, 0.42)) +
  theme_minimal() +
  theme(legend.position = "top")

gg2 <- polls_2020_with_trends_forecast %>%
  filter(party != "oth") %>%
  filter(mid >= ymd("2021-01-01")) %>%
  ggplot(., aes(x = mid, col = party)) +
  geom_point(aes(y = share), alpha = 0.1) +
  # geom_line(aes(y=rolling_mean_trend),linetype=2) +
  # geom_line(aes(y=continued_loess_trend),linetype=3) +
  geom_line(aes(y = extrapolated_loess_trend)) +
  geom_ribbon(aes(
    ymin = extrapolated_loess_trend - extrapolated_loess_moe,
    ymax = extrapolated_loess_trend + extrapolated_loess_moe, fill = party
  ),
  col = NA, alpha = 0.2
  ) +
  labs(x = "2021", y = "") +
  scale_y_continuous(labels = function(x) {
    x * 100
  }, limits = c(0, 0.42)) +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b")


png('latest-polls.png',width=700,height=900)
grid.arrange(gg1, gg2)
dev.off()


# save the raw data for use in the forecasting script
polls_2020_with_trends_forecast %>%
  write_csv(., "output-data/raw-for-forecast-polls-with-trends-2021.csv")


# writing to use in the forecast file
polls_trends_combine = polls_2020_with_trends_forecast %>%
  dplyr::select(mid, party, date, poll, n, share,
         trend = extrapolated_loess_trend,
         moe = extrapolated_loess_moe,
         imputed = to_impute,
  ) %>%
  mutate(
    date = NULL, poll = "trend",
    n = NULL, share = NULL,
  ) %>%
  distinct()

polls_trends_combine %>%
  rbind(polls_2020 %>% filter(!is.na(share))) %>%
  write_csv(., "output-data/polls-with-trends-2021.csv")

# writing to use in the poll tracker  
polls_tracker_out = polls_trends_combine %>%
  filter(party != 'oth') %>%
  group_by(mid) %>%
  mutate(
    majors_sum = sum(trend),
    seat_trend = trend/sum(trend),
    seat_moe = moe/sum(trend),
  ) %>%
  mutate_if(is.numeric, round, digits=4) %>%
  rbind(polls_2020 %>% filter(!is.na(share)))

# generate precis file
polls_trends_combine %>%
  filter(mid %in% c(Sys.Date())) %>%
  filter(poll == 'trend') %>%
  rbind(
    # 2017 result
    data.frame(
      mid=as.Date('2017-09-24'),
      party=c('cdu','spd','afd','fdp','lin','gru'),
      poll='result',
      trend=c(0.329, 0.205, 0.126, 0.107, 0.092, 0.089),
      moe=0,
      seat_trend = c(246/709, 153/709,94/709, 80/709, 69/709, 67/709),
      imputed=FALSE
    )
) %>% write_csv(., "output-data/topline-polls.csv")

polls_tracker_out %>%
  filter(mid %in% c(Sys.Date())) %>%
  filter(poll == 'trend') %>%
  rbind(
    # 2017 result
    data.frame(
      mid=as.Date('2017-09-24'),
      party=c('cdu','spd','afd','fdp','lin','gru'),
      poll='result',
      trend=c(0.329, 0.205, 0.126, 0.107, 0.092, 0.089),
      moe=0,
      seat_trend = c(246/709, 153/709,94/709, 80/709, 69/709, 67/709),
      imputed=FALSE
    )
) 
